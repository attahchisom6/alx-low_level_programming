#include "my_shell.h"

/**
 * is_searchable_dir - function to check if a path is searchable
 * note: a path is searchable if it is delimited by a semicolon ":"
 * @path:pointer to the path meant to be searched
 * @i:pointer to an integer counter
 *
 * Return:if 1 on success, 0 on failure
 */

int is_searchable_dir(char *path, int *k)
{
	if (path[*k] == ':')
		return (1);

	while (path[*k] != ':' && path[*k] != '\0')
		*k = *k + 1;

	if (path[*k] != '\0')
		*k = *k + 1;
	return (0);
}

/**
 * _which - function to locate a command line argument from the PATH
 * variable
 * @cmd:command line argument
 * @_environ:enviroment variable
 * 
 * Return:the concettenated cmd arg with path var at that point if
 * found
 */

char *_which(char *cmd, char **_environ)
{
	char *path, *ptr_path, *dir, *ptr_token;
	int k, cmd_len, token_len, len;
	struct stat st;

	if (cmd != NULL)
	{
		path = _getenv("PATH", _environ);
		ptr_path = _strdup(path);
		cmd_len = _strlen(cmd);
		ptr_token = my_strtok(ptr_path, ":");
		k = 0;
		while (ptr_token != NULL)
		{
			if (is_searchable_dir(ptr_token, &k) != 0)
				if (stat(cmd, &st) == 0)
					return (cmd);

			token_len = _strlen(ptr_token);
			len = token_len + cmd_len + 2;
			dir = malloc(len * sizeof(char));
			dir = _strcpy(dir, ptr_token);
			dir = _strcat(dir, "/");
			dir = _strcat(dir, cmd);
			dir = _strcat(dir, "\0");

			if (stat(dir, &st) == 0)
			{
				free(ptr_path);
				return (dir);
			}
			free(dir);

			ptr_token = my_strtok(NULL, ":");
		}
		free(ptr_token);

		if (stat(cmd, &st) == 0)
			return (cmd);
		return (NULL);
	}
	if (cmd[0] == '/')
		if (stat(cmd, &st) == 0)
			return (cmd);
	return (NULL);
}

/**
 * is_executable - function to check if a user input is executable
 * @mshell:my data structure
 *
 * Return:1 on success, 0 on failure
 */

int is_executable(m_data *mshell)
{
	char *input;
	unsigned int k = 0;
	struct stat st;

	while (input[k] != '\0')
	{
		if (input[k] == '.')
		{
			if (input[k + 1] == '.')
				return (0);
			else if (input[k + 1] == '/')
				continue;
			else
				break;
		}

		else if (input[k] == '/' && k == 0)
		{
			if (input[k + 1] == '.')
				continue;
			k++;
			break;
		}

		else
			break;
		k++;
	}

	if (k == 0)
		return (0);
	if (stat(&input[k], &st) == 0)
		return (k);

	/*get_error(mshell, 127);*/
	return (-1);
}

int main(void)
{
	int k;
	m_data mshell;

	mshell.argv[0] = "./a.out";
	k = is_executable(&mshell);
	return (0);
}
